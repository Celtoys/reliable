

Tuesday May 2nd, 2017
=====================

    9:50AM - Starting work.

        Continuing with endpoint work.

        Extended reliable configuration include void* context pointer. This will allow it to be used from C++.

        Now I need to get an array of acks working. This way I can implement tests that check the set of acks that work.

        Allocated and freed ack array.

        Added interface to get acks, clear ack array (avoids copy).

        Setup code to add acks to ack array.

    10:20AM - Finished work for morning.

        *** BREAK ***

    2:40PM - Back to work.

        It's time to bring across some tests for the ack system.

        Need to setup a framework with a sender and receiver, where packets are shunted in from one to the other in both directions.

        Getting started on this.

    3:21PM - Testing harness setup for endpoints. I should be able to implement an ack test now.

        Bringing across code from yojimbo for testing acks. See if this good, if not, write something new instead.

    3:52PM - Added a basic ack test with no packet loss. Passes.

        Next step is to add one with regular packet loss, eg. drop every 2nd packet, and make sure it comes up in the reported acks.

        Copying and pasting the test and doing this.

    3:57PM

        Nope. There is a bug in the ack system reported by the test on repeated reps. Digging in... it's missing ack #7 on the second run.

        Uninitialized data? Not possible. What could be causing it?!!!

    4:20PM - Logic error.

        I had something wrong in my code that was generating the sending ack. Added a separate variable and it's fixed. Was stepping up even # sequence # instead of all integers.



Monday May 1st, 2017
====================

    10:22AM - Starting work.

        Designing interface for endpoint. The main question basically is, do we use function pointers to send and process packets?

        I think the answer is yes. This is the easiest implementation for C and will integrate cleanly with C++. For other languages implementations, the decision of how to send packets can be different, for example, if it were a C++ implementation it would be a pure virtual method to be overridden or something like that.

        Either way, the standard part, which is the actual format of packets sent and received, is independent of this decision.

        Moving ahead with sketching out the interface.

    10:53AM - I have the reliable endpoint interface sketched out, short of the callbacks.

        Should the callbacks go in the config? Probably. It would be cleaner than having functions to set these callbacks.

        Adding this now.

    11:08AM - Added function pointers and a uint64_t "identifier" per-endpoint, which is passed to callbacks.

        For yojimbo on server, this would correspond to client index. 64bits allows the id to correspond to a pointer, or whatever else the user wants.

        Now moving ahead with implementation. Start with the packet send for now.

        Need to design the packet format. I think at minimum we need a prefix byte with flags.

        We have one flag that is definitely needed, which is fragment. This can be the low bit.

        If the bit is 1, then this is a fragment, and the rest of that start bit can be interpreted in a particular way (eg. fragment data in there)

        If the bit is 0, then this is a non-fragment, and perhaps we can stash some ack related stuff in the first byte, eg. a flag for perfect prediction.

        We could also stash congestion bits in the first byte, indicating that the other side thinks it is congested, or has detected bad network conditions.

        So don't worry too much about blowing a byte here, we can put useful information in there.

        Start with the byte being zero, meaning no flags, = regular packet, then follow this with the sequence, ack, ack bits data (w. no optimizations yet).

        Later on, we can try to do things like, derive the sequence # from the 64bit sequence sent from netcode.io, optimize for perfect ack bits etc.

        For now, just keep it simple!

    11:18AM - What is the first step here?

        Look at the yojimbo connection packet send and work out what needs to be done here.

    11:42AM - I have the send packet sketched out.

        Including the part up to calling the transmit packet function.

        To move forward I need to bring across netcode functions for reading and writing bytes, shorts, etc.

        Doing this now. Done.

        Now I can write the packet header.

        Done.

    11:52AM - Taking a lunch break.

        *** BREAK ***

     8:32PM - Time to implement the packet read.

        Packet read implemented. I think it's the correct call to have a process packet function pointer, because this way the process packet fn. can return false if it doesn't want a packet to be acked.

        Adding this now.

     9:41PM - Process packet function is working well.

        Next step is to add the array of acks that can be read by the user (but not via callback).

        Or alternatively, could provide a function callback on packet ack.

        Pros vs. cons? I think I like the ability to read off acks from an array better than a callback.

     9:45PM - Stop work for today.

        *** STOP WORK ***



Sunday April 30th, 2017
=======================

    8:30AM - Start work on reliable.io.

        This is the separation of the reliability system out of yojimbo, plus the addition of MTU fragmentation and reassembly.

        It is intended to make it possible to easily port to multiple languages, like C#, Golang, Rust etc.

        Its features will be:

            - pure c reference implementation

            - reliability system (eg. sequence, acks, ack bits)

            - an interface to get acks for packets via data structure, not callback (eg. get array of acks)

            - round trip time and packet loss estimates

            - BBR congestion avoidance (via notification, not immediate throttling)

                http://queue.acm.org/detail.cfm?id=3022184

                https://blog.acolyer.org/2017/03/31/bbr-congestion-based-congestion-control/

            - MTU packet fragmentation and reassembly

            - config struct that must be the same on both endpoints in order for the protocol to be compatible

    10:16AM - Sketched out basic project structure.

        This includes premake file, reliable.h, reliable.c, logging and asserts, test harness + setup git repo with gitignore.

        Moving forward now sketching out the config and endpoint structures.

        An endpoint is each side of the reliability system, eg. one on client, one on server per-client.

        Each endpoint must have the same configuration to be compatible, the configuration should be dynamic.

    10:30AM - Have the basic config and endpoint structures setup.

        What is the next step?

        I think it is to bring across the existing functionality from yojimbo for reliability system, commented out, so it can be used as reference.

        Actually, it's not this easy, as there are dependencies, plus the reliability system is yojimbo is spread across the connection system + message system.

        The best way would be to bring across dependencies first.

        These are:

            1. sequence buffer
            
            2. generate ack bits function

        I think netcode already has a sequence buffer port, so I can just bring that across and rename it.

        Nope. It doesn't. So this is basically the first step, port across the sequence buffer to "reliable_sequence_buffer" in C and test it.
        
        After this, port across generate ack bits to "reliable_generate_ack_bits" function.

    10:40AM - Taking a short break.

        *** BREAK ***

    11:23AM - Porting across the sequence buffer

        Going to be made a bit tricky by the fact that the sequence buffer is implemented in C++ with templates

        But I think as long as we know the stride of the sequence buffer entries, there should be no problem converting to C.

    12:04PM - Conversion continuing well.

        Sequence buffer functions ported across, stride based generic sequence buffer in C seems to be working well.

        Brought across supporting sequence functions.

        Rote converted from C++ to to.

    12:36PM - Finished converting sequence buffer to C.

        It's now ready to test.

        Converting unit test for sequence buffer.

    1:17PM - Finished converting across sequence buffer tests.

        *** BREAK ***

    4:33PM - What's the next step?

        Bringing across ack bits.

        Ack bits test passes.

    4:45PM - Break.

        *** BREAK ***

    5:23PM - Sketching out endpoint structure. What's it going to look like?

        I think it's mostly two sequence buffers (sent and received packets), the most recent sent sequence #, most recent received sequence #,
        plus some counters (these are very useful for testing and debugging...).

        Moving ahead with this.

    5:51PM - Basic structure for endpoint setup. 

        Implemented create and destroy for endpoint.

        Next I have to think for a while to decide on the interface for the endpoint.

        Fundamentally, I want to design it so that in the future I can reduce copies between it and netcode.io, in the common case.

        First, think of the user facing interface, it should present (in a version that copies), much like the interface for netcode.io, the user should be able to send packets and receive them, and it just looks normal. User should get sequence # of packets, but in this case sequence # should be 16 bit sequence # not 64bit.

        OK I can start from the outside in and design it this way. Later on, to improve performance, I can extend netcode.io and reliable.io interfaces so they have copy free versions.

    6:02PM - Taking a break.

        *** BREAK ***
